#pragma once

#include <chrono>
#include <ctime>
#include <filesystem>
#include <fstream>
#include <stdexcept>
#include <string>
#include <string_view>
#include <unordered_map>

#include <boost/json/src.hpp>

namespace benchmark::util {

/* Results-v2 format:
   {
       "date": "yyyy-mm-dd",
       "results": [
           {
               "name": "Algo, dataset[, other]",
               "time": milliseconds,
           }
       ]
   }
*/

class BenchmarkResultsIO {
public:
    /// @brief Load benchmark results saved with @c Save().
    /// @param filename must point to a @b valid JSON of Results-v2 format.
    /// @note Some checks are performed, but don't expect too much.
    static std::unordered_map<std::string, long long> Load(std::string_view filename) {
        std::filesystem::path file_path{filename};
        std::ifstream file{file_path};

        // This thing will throw file's stored exception, if one
        file.exceptions(file.rdstate());

        // This form of parse throws exceptions
        boost::json::value value = boost::json::parse(file);
        file.close();

        // Note: `as_...` functions may throw exceptions.
        // They are not translated into some very verbose format, because there may be only one
        // error -- JSON haven't been generated by `Save`
        auto top_level_obj = value.as_object();

        // Date is ignored here
        auto results_array = top_level_obj["results"].as_array();
        std::unordered_map<std::string, long long> results;
        for (auto const& bm_res : results_array) {
            auto bm_res_obj = bm_res.as_object();
            auto name_it = bm_res_obj.find("name");
            auto time_it = bm_res_obj.find("time");
            if (name_it == bm_res_obj.end()) {
                throw std::logic_error("Load: Benchmark result doesn't have name");
            }
            if (time_it == bm_res_obj.end()) {
                throw std::logic_error("Load: Benchmark result doesn't have time");
            }
            auto name = name_it->value();
            auto time = time_it->value();

            auto name_val = name.as_string();

            long long time_val;
            if (time.is_int64()) {
                time_val = time.as_int64();
            } else if (time.is_uint64()) {
                time_val = time.as_uint64();
            }
            results.emplace(name_val, time_val);
        }
        return results;
    }

    /// @brief Save benchmark results in Results-v2 format to be read with Load() later.
    /// @note Some checks are performed, but don't expect too much.
    static void Save(std::unordered_map<std::string, long long> const& results,
                     std::string_view filename) {
        std::filesystem::path file_path{filename};
        std::ofstream file{file_path};

        // This thing will throw file's stored exception, if one
        file.exceptions(file.rdstate());

        boost::json::object top_level_obj;

        auto now = std::chrono::system_clock::now();
        std::ostringstream date;
        // We use ancient GCC in CI, which doesn't support calendars, so I have to use C-style
        // output.
        // XXX(senichenkov): remove workaruond when we drop GCC-10 support
#if defined(__cpp_lib_chrono) && (__cpp_lib_chrono >= 201907L)
        std::chrono::year_month_day ymd = std::chrono::floor<std::chrono::days>(now);
        date << ymd;
#else
        auto const c_time = std::chrono::system_clock::to_time_t(now);
        date << std::put_time(std::localtime(&c_time), "%F");
#endif
        top_level_obj["date"] = date.str();

        boost::json::array results_arr;
        for (auto const& [name, bm_res] : results) {
            boost::json::object bm_obj({{"name", name}, {"time", bm_res}});
            results_arr.push_back(std::move(bm_obj));
        }
        top_level_obj["results"] = std::move(results_arr);

        file << top_level_obj << '\n';
    }
};

}  // namespace benchmark::util
