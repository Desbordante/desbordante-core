#pragma once

#include <filesystem>
#include <fstream>
#include <stdexcept>
#include <string>
#include <string_view>
#include <unordered_map>

#include <boost/json/src.hpp>

namespace benchmark::util {

class BenchmarkResultsIO {
public:
    /// @brief Load benchmark results saved with @c Save().
    /// @param filename must point to a @b valid JSON of exactly this format:
    ///		[{name: "HyFD", time: 100, threshold: 10}, ...]
    /// @note Some checks are performed, but don't expect too much.
    static std::unordered_map<std::string, long long> Load(std::string_view filename) {
        std::filesystem::path file_path{filename};
        std::ifstream file{file_path};

        // This thing will throw file's stored exception, if one
        file.exceptions(file.rdstate());

        // This form of parse throws exceptions
        boost::json::value value = boost::json::parse(file);
        file.close();

        // Note: `as_...` functions may throw exceptions.
        // They are not translated into some very verbose format, because there may be only one
        // error -- JSON haven't been generated by `Save`
        std::unordered_map<std::string, long long> results;
        auto obj = value.as_array();
        for (auto const& bm_res : obj) {
            auto bm_res_obj = bm_res.as_object();
            auto name_it = bm_res_obj.find("name");
            auto time_it = bm_res_obj.find("time");
            if (name_it == bm_res_obj.end()) {
                throw std::logic_error("Load: Benchmark result doesn't have name");
            }
            if (time_it == bm_res_obj.end()) {
                throw std::logic_error("Load: Benchmark result doesn't have time");
            }
            auto name = name_it->value();
            auto time = time_it->value();

            auto name_val = name.as_string();

            long long time_val;
            if (time.is_int64()) {
                time_val = time.as_int64();
            } else if (time.is_uint64()) {
                time_val = time.as_uint64();
            }
            results.emplace(name_val, time_val);
        }
        return results;
    }

    /// @brief Save benchmark results to be read with Load() later.
    /// @note Some checks are performed, but don't expect too much.
    static void Save(std::unordered_map<std::string, long long> const& results,
                     std::string_view filename) {
        std::filesystem::path file_path{filename};
        std::ofstream file{file_path};

        // This thing will throw file's stored exception, if one
        file.exceptions(file.rdstate());

        boost::json::array top_level_arr;
        for (auto const& [name, bm_res] : results) {
            boost::json::object bm_obj({{"name", name}, {"time", bm_res}});
            top_level_arr.push_back(std::move(bm_obj));
        }

        file << top_level_arr << '\n';
    }
};

}  // namespace benchmark::util
